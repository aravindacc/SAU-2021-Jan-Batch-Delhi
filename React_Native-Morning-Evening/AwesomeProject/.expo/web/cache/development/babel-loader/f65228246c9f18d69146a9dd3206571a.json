{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/assertThisInitialized\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nvar _jsxFileName = \"/home/saksham/Desktop/ReactNativeAssignment/AwesomeProject/node_modules/react-native-sticky-parallax-header/src/components/ScrollableTabView/ScrollableTabView.js\";\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nimport React from 'react';\nimport Animated from \"react-native-web/dist/exports/Animated\";\nimport StyleSheet from \"react-native-web/dist/exports/StyleSheet\";\nimport View from \"react-native-web/dist/exports/View\";\nimport { ViewPropTypes } from \"react-native-web/dist/index\";\nimport { func, node, number, oneOf } from 'prop-types';\nimport SceneComponent from \"./SceneComponent\";\nimport constants from \"../../constants/constants\";\nimport { getSafelyScrollNode } from \"../../utils\";\nvar styles = StyleSheet.create({\n  container: {\n    flex: 1\n  }\n});\nvar deviceWidth = constants.deviceWidth;\n\nvar ScrollableTabView = function (_React$Component) {\n  _inherits(ScrollableTabView, _React$Component);\n\n  var _super = _createSuper(ScrollableTabView);\n\n  function ScrollableTabView(props) {\n    var _this;\n\n    _classCallCheck(this, ScrollableTabView);\n\n    _this = _super.call(this, props);\n    _this.scrollOnMountCalled = false;\n\n    _this.onMomentumScrollBeginAndEnd = function (e) {\n      var _this$state = _this.state,\n          containerWidth = _this$state.containerWidth,\n          currentPage = _this$state.currentPage;\n      var swipedPage = _this.props.swipedPage;\n      var offsetX = e.nativeEvent.contentOffset.x;\n      var page = Math.round(offsetX / containerWidth);\n\n      if (currentPage !== page) {\n        swipedPage(page);\n\n        _this.onChangeTab(currentPage, page);\n\n        _this.updateSelectedPage(page);\n      }\n    };\n\n    _this.updateSelectedPage = function (nextPage) {\n      var localNextPage = nextPage;\n\n      if (typeof localNextPage === 'object') {\n        localNextPage = nextPage.nativeEvent.position;\n      }\n\n      _this.updateSceneKeys({\n        page: localNextPage\n      });\n    };\n\n    _this.composeScenes = function () {\n      return _this.children().map(function (child, idx) {\n        var key = _this.makeSceneKey(child, idx);\n\n        var _this$state2 = _this.state,\n            currentPage = _this$state2.currentPage,\n            containerWidth = _this$state2.containerWidth,\n            sceneKeys = _this$state2.sceneKeys;\n        var _this$props = _this.props,\n            contentContainerStyles = _this$props.contentContainerStyles,\n            minScrollHeight = _this$props.minScrollHeight;\n        return React.createElement(SceneComponent, {\n          key: child.key,\n          shouldUpdated: _this.shouldRenderSceneKey(idx, currentPage),\n          style: [{\n            width: containerWidth,\n            minHeight: minScrollHeight,\n            maxHeight: idx === currentPage ? null : minScrollHeight\n          }, contentContainerStyles],\n          __self: _assertThisInitialized(_this),\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 98,\n            columnNumber: 9\n          }\n        }, _this.keyExists(sceneKeys, key) ? child : null);\n      });\n    };\n\n    _this.makeSceneKey = function (child, idx) {\n      return child.props.tabLabel + \"_\" + idx;\n    };\n\n    _this.keyExists = function (sceneKeys, key) {\n      return sceneKeys.find(function (sceneKey) {\n        return key === sceneKey;\n      });\n    };\n\n    _this.shouldRenderSceneKey = function (idx, currentPageKey) {\n      return idx < currentPageKey + 1 && idx > currentPageKey - 1;\n    };\n\n    _this.polyfillAnimatedValue = function (animatedValue) {\n      var listeners = new Set();\n\n      var addListener = function addListener(listener) {\n        listeners.add(listener);\n      };\n\n      var removeListener = function removeListener(listener) {\n        listeners.delete(listener);\n      };\n\n      var removeAllListeners = function removeAllListeners() {\n        listeners.clear();\n      };\n\n      animatedValue.addListener = addListener;\n      animatedValue.removeListener = removeListener;\n      animatedValue.removeAllListeners = removeAllListeners;\n      return function (value) {\n        return listeners.forEach(function (listener) {\n          return listener({\n            value: value\n          });\n        });\n      };\n    };\n\n    _this.newSceneKeys = function (_ref) {\n      var _ref$previousKeys = _ref.previousKeys,\n          previousKeys = _ref$previousKeys === void 0 ? [] : _ref$previousKeys,\n          _ref$currentPage = _ref.currentPage,\n          currentPage = _ref$currentPage === void 0 ? 0 : _ref$currentPage,\n          _ref$children = _ref.children,\n          children = _ref$children === void 0 ? _this.props.children : _ref$children;\n      var newKeys = [];\n\n      _this.children(children).forEach(function (child, idx) {\n        var key = _this.makeSceneKey(child, idx);\n\n        if (_this.keyExists(previousKeys, key) || _this.shouldRenderSceneKey(idx, currentPage)) {\n          newKeys.push(key);\n        }\n      });\n\n      return newKeys;\n    };\n\n    _this.updateSceneKeys = function (_ref2) {\n      var page = _ref2.page,\n          _ref2$children = _ref2.children,\n          children = _ref2$children === void 0 ? _this.props.children : _ref2$children,\n          _ref2$callback = _ref2.callback,\n          callback = _ref2$callback === void 0 ? function () {} : _ref2$callback;\n      var sceneKeys = _this.state.sceneKeys;\n\n      var newKeys = _this.newSceneKeys({\n        previousKeys: sceneKeys,\n        currentPage: page,\n        children: children\n      });\n\n      _this.setState({\n        currentPage: page,\n        sceneKeys: newKeys\n      }, callback);\n    };\n\n    _this.goToPage = function (pageNumber) {\n      var containerWidth = _this.state.containerWidth;\n      var offset = pageNumber * containerWidth;\n      var scrollNode = getSafelyScrollNode(_this.scrollView);\n\n      if (scrollNode) {\n        scrollNode.scrollTo({\n          x: offset,\n          y: 0,\n          animated: true\n        });\n      }\n\n      var currentPage = _this.state.currentPage;\n\n      _this.updateSceneKeys({\n        page: pageNumber,\n        callback: _this.onChangeTab.bind(_assertThisInitialized(_this), currentPage, pageNumber)\n      });\n    };\n\n    _this.onScroll = function (e) {\n      var offsetX = e.nativeEvent.contentOffset.x;\n\n      if (offsetX === 0 && !_this.scrollOnMountCalled) {\n        _this.scrollOnMountCalled = true;\n      }\n    };\n\n    _this.handleLayout = function (e) {\n      var width = e.nativeEvent.layout.width;\n      var _this$state3 = _this.state,\n          containerWidth = _this$state3.containerWidth,\n          currentPage = _this$state3.currentPage;\n\n      if (!width || width <= 0 || Math.round(width) === Math.round(containerWidth)) {\n        return;\n      }\n\n      _this.setState({\n        containerWidth: width\n      });\n\n      requestAnimationFrame(function () {\n        _this.goToPage(currentPage);\n      });\n    };\n\n    _this.children = function () {\n      var children = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _this.props.children;\n      return React.Children.map(children, function (child) {\n        return child;\n      });\n    };\n\n    var initialPage = _this.props.initialPage;\n    var scrollXIOS = new Animated.Value(initialPage * deviceWidth);\n    var containerWidthAnimatedValue = new Animated.Value(deviceWidth);\n\n    containerWidthAnimatedValue.__makeNative();\n\n    var scrollValue = Animated.divide(scrollXIOS, containerWidthAnimatedValue);\n\n    var callListeners = _this.polyfillAnimatedValue(scrollValue);\n\n    _this.state = {\n      currentPage: initialPage,\n      scrollXIOS: scrollXIOS,\n      containerWidth: deviceWidth,\n      sceneKeys: _this.newSceneKeys({\n        currentPage: initialPage\n      })\n    };\n    scrollXIOS.addListener(function (_ref3) {\n      var value = _ref3.value;\n      return callListeners(value / deviceWidth);\n    });\n    return _this;\n  }\n\n  _createClass(ScrollableTabView, [{\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps) {\n      var _this$props2 = this.props,\n          children = _this$props2.children,\n          page = _this$props2.page;\n      var currentPage = this.state.currentPage;\n      if (children !== prevProps.children) this.updateSceneKeys({\n        page: currentPage,\n        children: children\n      });\n      if (page !== currentPage && page >= 0) this.goToPage(page);\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      var scrollXIOS = this.state.scrollXIOS;\n      scrollXIOS.removeAllListeners();\n    }\n  }, {\n    key: \"onChangeTab\",\n    value: function onChangeTab(prevPage, currentPage) {\n      var onChangeTab = this.props.onChangeTab;\n      onChangeTab({\n        i: currentPage,\n        ref: this.children()[currentPage],\n        from: prevPage\n      });\n    }\n  }, {\n    key: \"renderScrollableContent\",\n    value: function renderScrollableContent() {\n      var _this2 = this;\n\n      var scenes = this.composeScenes();\n      var initialPage = this.props.initialPage;\n      var _this$state4 = this.state,\n          containerWidth = _this$state4.containerWidth,\n          scrollXIOS = _this$state4.scrollXIOS;\n      var _this$props3 = this.props,\n          minScrollHeight = _this$props3.minScrollHeight,\n          keyboardShouldPersistTaps = _this$props3.keyboardShouldPersistTaps;\n      return React.createElement(Animated.ScrollView, {\n        keyboardShouldPersistTaps: keyboardShouldPersistTaps,\n        horizontal: true,\n        pagingEnabled: true,\n        contentContainerStyle: {\n          minHeight: minScrollHeight\n        },\n        automaticallyAdjustContentInsets: false,\n        contentOffset: {\n          x: initialPage * containerWidth\n        },\n        ref: function ref(scrollView) {\n          _this2.scrollView = scrollView;\n        },\n        onScroll: Animated.event([{\n          nativeEvent: {\n            contentOffset: {\n              x: scrollXIOS\n            }\n          }\n        }], {\n          useNativeDriver: true,\n          listener: this.onScroll\n        }),\n        onMomentumScrollEnd: this.onMomentumScrollBeginAndEnd,\n        scrollEventThrottle: 16,\n        scrollsToTop: false,\n        showsHorizontalScrollIndicator: false,\n        scrollEnabled: true,\n        directionalLockEnabled: true,\n        alwaysBounceVertical: false,\n        keyboardDismissMode: \"on-drag\",\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 210,\n          columnNumber: 7\n        }\n      }, scenes);\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      return React.createElement(View, {\n        style: styles.container,\n        onLayout: this.handleLayout,\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 239,\n          columnNumber: 7\n        }\n      }, this.renderScrollableContent());\n    }\n  }]);\n\n  return ScrollableTabView;\n}(React.Component);\n\nScrollableTabView.propTypes = {\n  children: node,\n  contentContainerStyles: ViewPropTypes.style,\n  initialPage: number,\n  page: number,\n  onChangeTab: func,\n  swipedPage: func,\n  minScrollHeight: number,\n  keyboardShouldPersistTaps: oneOf(['never', 'always', 'handled', false, true, undefined])\n};\nScrollableTabView.defaultProps = {\n  contentContainerStyles: {},\n  initialPage: 0,\n  page: -1,\n  onChangeTab: function onChangeTab() {},\n  keyboardShouldPersistTaps: undefined\n};\nexport default ScrollableTabView;","map":{"version":3,"sources":["/home/saksham/Desktop/ReactNativeAssignment/AwesomeProject/node_modules/react-native-sticky-parallax-header/src/components/ScrollableTabView/ScrollableTabView.js"],"names":["React","ViewPropTypes","func","node","number","oneOf","SceneComponent","constants","getSafelyScrollNode","styles","StyleSheet","create","container","flex","deviceWidth","ScrollableTabView","props","scrollOnMountCalled","onMomentumScrollBeginAndEnd","e","state","containerWidth","currentPage","swipedPage","offsetX","nativeEvent","contentOffset","x","page","Math","round","onChangeTab","updateSelectedPage","nextPage","localNextPage","position","updateSceneKeys","composeScenes","children","map","child","idx","key","makeSceneKey","sceneKeys","contentContainerStyles","minScrollHeight","shouldRenderSceneKey","width","minHeight","maxHeight","keyExists","tabLabel","find","sceneKey","currentPageKey","polyfillAnimatedValue","animatedValue","listeners","Set","addListener","listener","add","removeListener","delete","removeAllListeners","clear","value","forEach","newSceneKeys","previousKeys","newKeys","push","callback","setState","goToPage","pageNumber","offset","scrollNode","scrollView","scrollTo","y","animated","bind","onScroll","handleLayout","layout","requestAnimationFrame","Children","initialPage","scrollXIOS","Animated","Value","containerWidthAnimatedValue","__makeNative","scrollValue","divide","callListeners","prevProps","prevPage","i","ref","from","scenes","keyboardShouldPersistTaps","event","useNativeDriver","renderScrollableContent","Component","propTypes","style","undefined","defaultProps"],"mappings":"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","sourcesContent":["/* eslint-disable react/destructuring-assignment  */\nimport React from 'react';\nimport { Animated, StyleSheet, View, ViewPropTypes } from 'react-native';\nimport { func, node, number, oneOf } from 'prop-types';\nimport SceneComponent from './SceneComponent';\nimport constants from '../../constants/constants';\nimport { getSafelyScrollNode } from '../../utils';\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n  },\n});\n\nconst { deviceWidth } = constants;\n\nclass ScrollableTabView extends React.Component {\n  scrollOnMountCalled = false;\n\n  constructor(props) {\n    super(props);\n    const { initialPage } = this.props;\n\n    const scrollXIOS = new Animated.Value(initialPage * deviceWidth);\n    const containerWidthAnimatedValue = new Animated.Value(deviceWidth);\n\n    // eslint-disable-next-line no-underscore-dangle\n    containerWidthAnimatedValue.__makeNative();\n    const scrollValue = Animated.divide(scrollXIOS, containerWidthAnimatedValue);\n\n    const callListeners = this.polyfillAnimatedValue(scrollValue);\n\n    this.state = {\n      currentPage: initialPage,\n      scrollXIOS,\n      containerWidth: deviceWidth,\n      sceneKeys: this.newSceneKeys({ currentPage: initialPage }),\n    };\n\n    scrollXIOS.addListener(({ value }) => callListeners(value / deviceWidth));\n  }\n\n  componentDidUpdate(prevProps) {\n    const { children, page } = this.props;\n    const { currentPage } = this.state;\n\n    if (children !== prevProps.children) this.updateSceneKeys({ page: currentPage, children });\n\n    if (page !== currentPage && page >= 0) this.goToPage(page);\n  }\n\n  componentWillUnmount() {\n    const { scrollXIOS } = this.state;\n\n    scrollXIOS.removeAllListeners();\n  }\n\n  onMomentumScrollBeginAndEnd = (e) => {\n    const { containerWidth, currentPage } = this.state;\n    const { swipedPage } = this.props;\n    const offsetX = e.nativeEvent.contentOffset.x;\n    const page = Math.round(offsetX / containerWidth);\n\n    if (currentPage !== page) {\n      swipedPage(page);\n      this.onChangeTab(currentPage, page);\n      this.updateSelectedPage(page);\n    }\n  };\n\n  onChangeTab(prevPage, currentPage) {\n    const { onChangeTab } = this.props;\n    onChangeTab({\n      i: currentPage,\n      ref: this.children()[currentPage],\n      from: prevPage,\n    });\n  }\n\n  updateSelectedPage = (nextPage) => {\n    let localNextPage = nextPage;\n    if (typeof localNextPage === 'object') {\n      localNextPage = nextPage.nativeEvent.position;\n    }\n\n    this.updateSceneKeys({\n      page: localNextPage,\n    });\n  };\n\n  composeScenes = () =>\n    this.children().map((child, idx) => {\n      const key = this.makeSceneKey(child, idx);\n      const { currentPage, containerWidth, sceneKeys } = this.state;\n      const { contentContainerStyles, minScrollHeight } = this.props;\n\n      return (\n        <SceneComponent\n          key={child.key}\n          shouldUpdated={this.shouldRenderSceneKey(idx, currentPage)}\n          style={[\n            // used to calculate current height of scroll\n            // eslint-disable-next-line react-native/no-inline-styles\n            {\n              width: containerWidth,\n              minHeight: minScrollHeight,\n              maxHeight: idx === currentPage ? null : minScrollHeight,\n            },\n            contentContainerStyles,\n          ]}>\n          {this.keyExists(sceneKeys, key) ? child : null}\n        </SceneComponent>\n      );\n    });\n\n  makeSceneKey = (child, idx) => `${child.props.tabLabel}_${idx}`;\n\n  keyExists = (sceneKeys, key) => sceneKeys.find((sceneKey) => key === sceneKey);\n\n  // eslint-disable-next-line max-len\n  shouldRenderSceneKey = (idx, currentPageKey) =>\n    idx < currentPageKey + 1 && idx > currentPageKey - 1;\n\n  polyfillAnimatedValue = (animatedValue) => {\n    const listeners = new Set();\n    const addListener = (listener) => {\n      listeners.add(listener);\n    };\n\n    const removeListener = (listener) => {\n      listeners.delete(listener);\n    };\n\n    const removeAllListeners = () => {\n      listeners.clear();\n    };\n\n    /* eslint-disable no-param-reassign  */\n    animatedValue.addListener = addListener;\n    animatedValue.removeListener = removeListener;\n    animatedValue.removeAllListeners = removeAllListeners;\n    /* eslint-disable no-param-reassign  */\n\n    return (value) => listeners.forEach((listener) => listener({ value }));\n  };\n\n  newSceneKeys = ({ previousKeys = [], currentPage = 0, children = this.props.children }) => {\n    const newKeys = [];\n    this.children(children).forEach((child, idx) => {\n      const key = this.makeSceneKey(child, idx);\n      if (this.keyExists(previousKeys, key) || this.shouldRenderSceneKey(idx, currentPage)) {\n        newKeys.push(key);\n      }\n    });\n\n    return newKeys;\n  };\n\n  updateSceneKeys = ({ page, children = this.props.children, callback = () => {} }) => {\n    const { sceneKeys } = this.state;\n    const newKeys = this.newSceneKeys({ previousKeys: sceneKeys, currentPage: page, children });\n    this.setState({ currentPage: page, sceneKeys: newKeys }, callback);\n  };\n\n  goToPage = (pageNumber) => {\n    const { containerWidth } = this.state;\n    const offset = pageNumber * containerWidth;\n    const scrollNode = getSafelyScrollNode(this.scrollView);\n    if (scrollNode) {\n      scrollNode.scrollTo({ x: offset, y: 0, animated: true });\n    }\n\n    const { currentPage } = this.state;\n    this.updateSceneKeys({\n      page: pageNumber,\n      callback: this.onChangeTab.bind(this, currentPage, pageNumber),\n    });\n  };\n\n  onScroll = (e) => {\n    const offsetX = e.nativeEvent.contentOffset.x;\n    if (offsetX === 0 && !this.scrollOnMountCalled) {\n      this.scrollOnMountCalled = true;\n    }\n  };\n\n  handleLayout = (e) => {\n    const { width } = e.nativeEvent.layout;\n    const { containerWidth, currentPage } = this.state;\n\n    if (!width || width <= 0 || Math.round(width) === Math.round(containerWidth)) {\n      return;\n    }\n\n    this.setState({ containerWidth: width });\n    requestAnimationFrame(() => {\n      this.goToPage(currentPage);\n    });\n  };\n\n  children = (children = this.props.children) => React.Children.map(children, (child) => child);\n\n  renderScrollableContent() {\n    const scenes = this.composeScenes();\n    const { initialPage } = this.props;\n    const { containerWidth, scrollXIOS } = this.state;\n    const { minScrollHeight, keyboardShouldPersistTaps } = this.props;\n\n    return (\n      <Animated.ScrollView\n        keyboardShouldPersistTaps={keyboardShouldPersistTaps}\n        horizontal\n        pagingEnabled\n        contentContainerStyle={{ minHeight: minScrollHeight }}\n        automaticallyAdjustContentInsets={false}\n        contentOffset={{ x: initialPage * containerWidth }}\n        ref={(scrollView) => {\n          this.scrollView = scrollView;\n        }}\n        onScroll={Animated.event([{ nativeEvent: { contentOffset: { x: scrollXIOS } } }], {\n          useNativeDriver: true,\n          listener: this.onScroll,\n        })}\n        onMomentumScrollEnd={this.onMomentumScrollBeginAndEnd}\n        scrollEventThrottle={16}\n        scrollsToTop={false}\n        showsHorizontalScrollIndicator={false}\n        scrollEnabled\n        directionalLockEnabled\n        alwaysBounceVertical={false}\n        keyboardDismissMode=\"on-drag\">\n        {scenes}\n      </Animated.ScrollView>\n    );\n  }\n\n  render() {\n    return (\n      <View style={styles.container} onLayout={this.handleLayout}>\n        {this.renderScrollableContent()}\n      </View>\n    );\n  }\n}\n\nScrollableTabView.propTypes = {\n  children: node,\n  contentContainerStyles: ViewPropTypes.style,\n  initialPage: number,\n  page: number,\n  onChangeTab: func,\n  swipedPage: func,\n  minScrollHeight: number,\n  keyboardShouldPersistTaps: oneOf(['never', 'always', 'handled', false, true, undefined]),\n};\n\nScrollableTabView.defaultProps = {\n  contentContainerStyles: {},\n  initialPage: 0,\n  page: -1,\n  onChangeTab: () => {},\n  keyboardShouldPersistTaps: undefined,\n};\n\nexport default ScrollableTabView;\n"]},"metadata":{},"sourceType":"module"}